### **1. Basics of JavaScript**
#### **Syntax and Operators**
- **Syntax**: JavaScript code follows specific rules and conventions.
  ```js
  let a = 10; // Variable declaration
  const b = 20; // Constant declaration
  ```
- **Operators**: Used to assign values, compare values, and perform arithmetic operations.
  - **Assignment**: `=`, `+=`, `-=`, `*=`, `/=`
  - **Arithmetic**: `+`, `-`, `*`, `/`, `%`
  - **Comparison**: `==`, `===`, `!=`, `!==`, `>`, `<`
  - **Logical**: `&&`, `||`, `!`

#### **Variables and Data Types**
- **Primitive Data Types**: String, Number, Boolean, Undefined, Null, Symbol
- **Non-Primitive Data Types**: Object, Array, Function

  ```js
  let name = "John"; // String
  let age = 30; // Number
  let isAdult = true; // Boolean
  ```

#### **Type Coercion and Type Conversion**
- **Coercion**: Automatic or implicit conversion of data types.
  ```js
  let result = 5 + "5"; // "55" (Number coerced to String)
  ```

- **Type Conversion**: Manual conversion using methods like `Number()`, `String()`, `Boolean()`.
  ```js
  let num = String(123); // "123"
  let str = Boolean(0); // false
  ```

---

### **2. Control Flow**
#### **Conditional Statements**
- **If-Else**
  ```js
  let x = 10;
  if (x > 5) {
      console.log("Greater than 5");
  } else {
      console.log("Less than or equal to 5");
  }
  ```
  
- **Switch Case**
  ```js
  let day = 3;
  switch (day) {
    case 1:
      console.log("Monday");
      break;
    case 2:
      console.log("Tuesday");
      break;
    default:
      console.log("Invalid day");
  }
  ```

#### **Loops**
- **For Loop**
  ```js
  for (let i = 0; i < 5; i++) {
      console.log(i);
  }
  ```

- **While Loop**
  ```js
  let i = 0;
  while (i < 5) {
      console.log(i);
      i++;
  }
  ```

---

### **3. Functions**
#### **Function Declaration vs Expressions**
- **Declaration**: Function is hoisted.
  ```js
  function greet() {
      console.log("Hello");
  }
  ```

- **Expression**: Not hoisted, assigned to variables.
  ```js
  const greet = function() {
      console.log("Hello");
  };
  ```

#### **Arrow Functions**
- **Shorter syntax for function expressions**:
  ```js
  const add = (a, b) => a + b;
  ```

#### **Function Scope and Closures**
- **Scope**: Where a variable is accessible (Global, Local).
- **Closures**: A function that retains access to variables from its lexical scope even when called outside that scope.
  ```js
  function outer() {
      let counter = 0;
      return function inner() {
          counter++;
          console.log(counter);
      };
  }
  const count = outer();
  count(); // 1
  count(); // 2
  ```

---

### **4. Objects and Arrays**
#### **Objects**
- **Creating Objects**
  ```js
  const person = {
    name: "John",
    age: 30,
    greet() {
      console.log("Hello");
    }
  };
  ```

#### **Array Methods**
- **Map**: Transforms an array.
  ```js
  let nums = [1, 2, 3];
  let doubled = nums.map(num => num * 2); // [2, 4, 6]
  ```

- **Reduce**: Reduces array to a single value.
  ```js
  let sum = nums.reduce((acc, num) => acc + num, 0); // 6
  ```

- **Filter**: Filters array based on condition.
  ```js
  let evenNumbers = nums.filter(num => num % 2 === 0); // [2]
  ```

---

### **5. Asynchronous JavaScript**
#### **Callbacks**
- Functions passed as arguments to other functions.
  ```js
  function fetchData(callback) {
      setTimeout(() => {
          callback("Data fetched");
      }, 1000);
  }
  fetchData(data => console.log(data)); // "Data fetched"
  ```

#### **Promises**
- Represent the eventual completion or failure of an asynchronous operation.
  ```js
  let myPromise = new Promise((resolve, reject) => {
      let success = true;
      if (success) {
          resolve("Success");
      } else {
          reject("Error");
      }
  });
  myPromise.then(result => console.log(result)).catch(err => console.log(err));
  ```

#### **Async/Await**
- **Simplified syntax for working with Promises.**
  ```js
  async function fetchData() {
      let data = await myPromise;
      console.log(data);
  }
  fetchData(); // "Success"
  ```

---

### **6. Scope and Closures**
- **Lexical Scope**: Scope defined by the location of variables and functions in the code during the programâ€™s execution.
- **Hoisting**: JavaScript hoists declarations to the top of their scope, but not initializations.

---

### **7. The `this` Keyword**
- **Default Binding**: Refers to the global object in non-strict mode.
  ```js
  console.log(this); // Window (in browsers)
  ```

- **Implicit Binding**: Refers to the object before the dot in method calls.
  ```js
  const person = {
      name: "Alice",
      greet() {
          console.log(this.name);
      }
  };
  person.greet(); // "Alice"
  ```

- **Explicit Binding**: Using `call`, `apply`, or `bind`.
  ```js
  function greet() {
      console.log(this.name);
  }
  const person = { name: "Bob" };
  greet.call(person); // "Bob"
  ```

---

### **8. Error Handling**
#### **Try, Catch, Finally**
- **Try-Catch**: Handles errors gracefully.
  ```js
  try {
      let result = 10 / 0;
  } catch (error) {
      console.log("Error: Division by zero");
  }
  ```

---

### **9. ES6+ Features**
#### **Classes and Inheritance**
- **Class**: Defines a blueprint for objects.
  ```js
  class Person {
      constructor(name, age) {
          this.name = name;
          this.age = age;
      }
      greet() {
          console.log(`Hello, my name is ${this.name}`);
      }
  }
  const john = new Person("John", 30);
  john.greet(); // "Hello, my name is John"
  ```

#### **Modules**
- **Import and Export**
  ```js
  // math.js
  export function add(a, b) { return a + b; }
  
  // main.js
  import { add } from './math.js';
  console.log(add(2, 3)); // 5
  ```

---

### **10. DOM Manipulation**
- **Selecting Elements**:
  ```js
  let element = document.querySelector("#myElement");
  ```

- **Changing Content**:
  ```js
  element.textContent = "New Text";
  ```

---

### **11. Asynchronous JavaScript**
- **Event Loop**: Handles asynchronous operations by pushing them to the message queue after the call stack is empty.

---

### **12. Best Practices**
- **Avoiding Global Variables**: Reduces conflicts and bugs.
- **DRY Principle**: Don't Repeat Yourself.

